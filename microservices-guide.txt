1. Каждый микросервис в данном проекте, это отдельная папка в корне.
2. Для каждого микросервиса мы создаем отдельные сервисы в docker-compose файле \


go run github.com/99designs/gqlgen generate - запуск генерации схемы Graphql

4:34:52
38:27 - докер

СТРУКТУРА ЗАПРОСА В МИКРОСЕРВИСАХ = API GATEWAY -> CLIENT -> SERVER -> SERVICE -> REPOSITORY -> DATABASE

1️⃣ CLIENT – gRPC-клиент, который отправляет запросы серверу.

Вызывает методы pb.NewCatalogServiceClient(conn), чтобы отправить gRPC-запрос в микросервис.
Может находиться внутри API Gateway, другого микросервиса или в тестовом приложении.

2️⃣ SERVER – gRPC-сервер, который принимает запросы от клиента.

Реализует gRPC-интерфейс (например, PostProduct(ctx, req)).
Вызывает бизнес-логику (Service), а затем передает результат обратно клиенту.

3️⃣ SERVICE – бизнес-логика приложения.

Реализует основную логику работы с данными.
Может вызывать Repository для взаимодействия с базой данных.
Например, если поступает запрос на создание продукта, Service проверяет входные данные, вызывает Repository для сохранения в БД и возвращает результат серверу.

4️⃣ REPOSITORY – слой работы с базой данных.

Выполняет CRUD-операции через ORM (например, GORM) или SQL-запросы.
Например, repository.SaveProduct(product) сохраняет продукт в БД.

CLIENT вызывает PostProduct через gRPC.
SERVER принимает запрос и передает его в SERVICE.
SERVICE обрабатывает логику (например, проверяет, что цена > 0).
SERVICE вызывает REPOSITORY, чтобы сохранить продукт в БД.
REPOSITORY выполняет SQL-запрос и возвращает результат.
SERVICE передает данные обратно в SERVER.
SERVER отправляет ответ CLIENT'у.